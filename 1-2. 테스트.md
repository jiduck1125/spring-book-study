# 2. 테스트
테스트는 만들어진 코드가 의도한 대로 동작하는지를 확인해서 코드에 대한 확신을 가질 수 있게 해준다. 또한 테스트 결과가 원하는 대로 나오지 않는다면 코드나 설계에 결함이 있음을 알 수 있다. 코드를 수정하고 테스트가 성공하면 결함이 제거되었다는 확신을 가질 수 있다.

#### 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트해야 한다. 한번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다. 

작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트라고 한다. 여기서 단위는 크기와 범위가 딱 정해진 건 아니지만 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.

일반적으로 단위는 작을수록 좋다. 단위를 넘어서는 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 가능한 것이 좋다.

물론 단위 기능으로는 잘 동작하는데 여러 단위를 묶어서 테스트하면 안되는 경우가 종종 있기 때문에 긴 테스트도 필요하다. 하지만 단위 테스트로 충분히 검증을 마치고 긴 테스트를 하면 오류의 원인을 찾기가 훨씬 쉬울 것이다.

단위 테스트는 개발자가 작성한 코드가 의도한 대로 동작하는지 빠르게 확인하기 위해서도 필요하다. 개발하고 한참 뒤에 고객이나 테스터가 테스트를 하는 시점엔 오류가 발견되어도 고치는데 시간이 걸릴 것이다.

#### 자동수행 테스트 코드
테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. 테스트가 사람의 수작업을 거쳐야 한다면 테스트를 자주 반복해서 수행하기가 어렵다. 자동으로 수행되는 테스트는 번거롭지 않고 빠르게 실행이 가능하기 때문에 자주 반복해서 수행할 수 있다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트
테스트가 없다면 코드를 수정하고 설계를 개선해나가기가 어려워질 것이다. 테스트를 진행하면서 코드를 조금씩 수정하면서 어디가 문제인지 바로 확인할 수 있다. 그리고 새로운 기능을 추가할 때도 테스트를 이용하면 기존에 있던 기능에 영향이 없는지를 확인할 수 있다.

### 테스팅 프레임워크 JUnit
JUnit은 자바의 표준 테스팅 프레임워크라고 불릴 만큼 폭넓게 사용된다. 스프링 테스트 모듈도 JUnit을 사용한다. JUnit은 테스트는 단순하기 때문에 빠르게 작성이 가능하고, 테스트 작성시 필요한 여러 부가기능도 제공한다.

JUnit 프레임워크에서 테스트 메소드는 public으로 선언되어야 하고, @Test라는 애노테이션을 붙여줘야 한다.

테스트 결과를 검증하기 위해 assertThat()을 사용할 수 있다. 조건이 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하게 만들어준다.
다음과 같이 is()를 사용해 equals()로 비교한 결과를 검증할 수 있다.
```java
@Test
public void add() {
    ...
    assertThat(user1.getName(), is(user.getName()));
    ...
}
```

#### JUnit 테스트 실행
테스트 메소드를 실행하도록 하려면 아래와 같이 JUnit 프레임워크를 시작시켜 줘야 한다. JUnitCore의 main 메소드에 파라미터로 테스트 클래스의 이름을 넣어주면 된다.
```java
public static void main(String[] args) {
    JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

예외가 발생하는 조건을 테스트하기 위해 다음과 같이 특정 예외가 발생해야 테스트가 성공하도록 할 수도 있다.
```java
@Test(expected=EmptyResultDataAccessException.class)
```

매번 테스트 메소드를 실행하기 전에 실행되어야 하는 코드가 있다면 @Before 애노테이션을 사용하면 된다. 
테스트 메소드를 실행한 이후에 실행되어야 하는 코드가 있다면 @After 애노테이션을 사용하면 된다. 테스트에 필요한 공통 준비 작업이나 정리 작업을 처리할 때 사용할 수 있다.


### 포괄적인 테스트
테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 매우 위험하다. 미처 생각하지 못한 곳에서 문제가 발생할 수 있다.

모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다.

### 테스트 주도 개발
만들고자 하는 기능의 내용을 담고 있으면서 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발(TDD)이라고 한다. 

정신없이 개발을 하다 보면 테스트 코드를 만들고 점검할 타이밍을 놓치는 경우가 많다. 
TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식이기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들게 된다.

또한 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간 간격이 짧아진다. 이미 테스트를 만들어뒀기 때문에 코드를 작성하고 바로바로 테스트를 해볼 수 있기 때문이다. 개발한 코드의 오류는 빨리 발견할수록 쉽게 대응이 가능하다.

테스트 코드는 작성하고 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트 없이 한번에 너무 많은 코드를 만드는 것은 좋지 않다.

테스트를 만들고 자주 실행하면 개발이 지연되지 않을까 걱정이 될수도 있다. 하지만 테스트는 애플리케이션 코드보다 상대적으로 작성하기 쉽고 각 테스트가 독립적이기 때문에, 코드의 양에 비해 작성하는 시간은 얼마 걸리지 않는다. 테스트 덕분에 오류를 빨리 잡을 수 있어서 전체적인 개발 속도는 오히려 빨라진다.

### 스프링 테스트 컨텍스트
JUnit은 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다.
한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 실행하고 나면 버려진다. 
JUnit에서 테스트를 실행할 때마다 새로운 오브젝트를 만드는 이유는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실하게 보장하기 위해서다.

하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다. 스프링에서 제공하는 테스트 컨텍스트 지원 기능을 사용하면 애플리케이션 컨텍스트를 만들어 모든 테스트가 공유하게 할 수 있다. 스프링 테스트 컨텍스트를 이용하면 애플리케이션 컨텍스트를 한 번만 만들고 다른 테스트에서 재사용할 수 있어서 테스트 실행 시간이 짧아지게 된다.

예를 들어 애플리케이션 컨텍스트를 생성하기 위해 @Before 메소드로 다음과 같이 사용했다면
```java
@Before
public void setUp() {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
    ...
}
```

스프링 테스트 컨텍스트를 적용해 아래와 같이 작성할 수 있다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
    @Autowired
    private ApplicationContext context;
}
```
테스트 컨텍스트에 의해 @Autowired 변수에 자동으로 값이 주입된다. 
@RunWith는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다. SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 동안 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다. @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 위치를 지정한 것이다.

#### 테스트 클래스의 컨텍스트 공유
스프링 테스트 컨텍스트 프레임워크는 여러 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유할 수 있게 해준다. 동일한 설정파일을 사용하는 테스트 클래스는 하나의 애플리케이션 컨텍스트를 공유한다.

#### @Autowired
@Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 빈을 찾아서 주입해준다. 만약 같은 타입의 빈이 두 개 이상이면 변수의 이름과 같은 이름의 빈을 찾는다. 생성자나 수정자 메소드가 없어도 주입이 가능하다.

그리고 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록하기 때문에 ApplicationContext는 설정파일에 정의되어 있지 않아도 DI가 가능하다.

#### 컨테이너 없는 DI 테스트
아예 스프링 컨테이너를 사용하지 않고 테스트를 만들 수도 있다.
다음과 같이 테스트 코드에서 직접 오브젝트를 만들고 수동 DI해서 사용하면 된다.
```java
public class UserDaoTest {
    UserDao dao;

    @Before
    public void setUp() {
        ...
        dao = new UserDao();
        DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql://localhost/testdb", "spring", "book", true);
        dao.setDataSource(dataSource);
    }
}
```

## 학습 테스트
다른 사람이 만든 프레임워크나 라이브러리에 대해 사용방법을 익히기 위해 테스트를 작성하는 것을 학습 테스트라고 한다. 기능 검증이 목적이 아니라 자신이 해당 기술이나 기능에 대해 얼마나 이해하고 있는지, 사용 방법을 제대로 알고 있는지를 검증하는 것이 목적이다. 테스트를 작성해보면서 빠르고 정확하게 사용법을 익히는 것도 학습 테스트를 작성하는 목적이다.

학습 테스트는 다음과 같은 장점이 있다.
- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다. 학습 테스트는 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따른 기능 동작을 빠르게 확인할 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다. 새로운 기술의 다양한 기능을 사용하는 코드를 만들어두면 나중에 실제 개발에서 샘플 코드로 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다. 학습 테스트로 미리 새로운 버전을 테스트 해보면 변화가 있거나 버그가 있는지 미리 확인해 볼 수 있다. API의 사용 방법이 변경된 경우에도 그에 맞춰 코드를 수정할 계획을 세울 수 있다.
- 테스트 작성에 대한 좋은 훈련이 된다. 학습 테스트를 작성해보면서 테스트 코드 작성을 연습할 수 있다.
- 새로운 기술을 공부하는 과정이 즐거워진다. 책이나 문서를 읽기만 하는 것보다 테스트 코드를 만들면서 학습하는 것이 더 재미있다.

### 버그 테스트
버그 테스트란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.
버그 테스트는 버그가 원인이 되어서 실패하도록 만들어야 한다. 그리고 나서 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정하는 것이다.

버그 테스트의 필요성과 장점은 다음과 같다.
- 테스트의 완성도를 높여준다. 기존 테스트에서 검증하지 못했기 때문에 오류가 발생한 것이기 때문에 이에 대한 테스트를 만들면 불충분했던 테스트를 보완해줄 수 있다.
- 버그의 내용을 명확하게 분석하게 해준다. 어떤 이유로 문제가 생겼는지 명확히 알아야 테스트로 만들기 때문이다.
- 기술적인 문제를 해결하는 데 도움이 된다. 버그의 원인이 뭔지 정확히 파악하기 힘들 땐 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다. 외부에 도움을 요청할 때도 도움이 된다.