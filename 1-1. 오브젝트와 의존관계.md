# 오브젝트와 의존관계
스프링은 객체지향 언어인 자바를 기반으로 한 기술이다.
스프링은 객체지향 설계와 구현을 쉽고 자연스럽게 적용할 수 있도록 실용적인 전략과 베스트 프랙티스를 프레임워크 형태로 제공한다.

JDBC API를 사용해 데이터를 가져오는 DAO를 만든다고 해보자.
JDBC로 조회하는 작업은 다음과 같은 순서로 진행된다.

- DB 연결을 위한 Connection을 가져온다.
- SQL을 담은 Statement(PreparedStatement)를 만든다
- 만들어진 Statement를 실행한다.
- SQL 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 담아준다.
- 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스를 반드시 닫아준다.
- JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드 밖으로 던진다.

## 관심사의 분리
소프트웨어 개발에서 요구사항은 끊임없이 변한다. 따라서 객체를 설계할 때 가장 염두에 둬야하는 사항은 변화를 어떻게 대비할 것인가이다.

가장 좋은 대책은 변화의 폭을 최소한으로 줄이는 것이다. 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 해야한다.

따라서 변경에 따른 작업이 한 곳에 집중되도록 한 가지 관심사가 한 군데에 집중되게 해야한다. 즉, 관심이 같은 것끼리 모으고, 관심이 다른 것은 따로 떨어져 있게 해서 영향을 주지 않게 한다.

## 중복 코드의 메소드 추출
위의 DAO에서 관심사는 세가지로 구분할 수 있다.
- DB 연결을 위한 커넥션을 가져오는 것
- DB에 보낼 SQL을 담을 Statement를 만들고 실행하는 것
- 작업이 끝난 리소스를 닫아주는 것

모든 DAO의 로직에 위 작업을 하는 코드가 중복된다면 변경이 일어났을 때 엄청나게 힘들어진다.
여기서 중복 코드를 메소드로 추출한다면 변경이 발생했을 때 한 메소드의 코드만 수정하면 된다. 다른 메소드에는 영향을 주지도 않고 수정도 간단해진다. 리팩토링에서는 메소드 추출 기법이라고 한다.

아래와 같이 유저 조회에서 DB 커넥션을 가져오는 코드를 메소드로 분리할 수 있다.
```java
public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
    return c;
}
```

## 상속을 통한 확장
DAO의 소스를 직접 수정하지 않고 원하는 DB 커넥션 방식을 사용하려면 어떻게 해야할까?
커넥션을 가져오는 메소드를 추상 메소드로 만들면 된다. 추상 클래스를 상속해서 커넥션을 가져오는 메소드만 구현해서 쓰도록 하면 된다.
그러면 DAO 슈퍼클래스는 어떤 기능을 사용한다는 데에만 관심이 있고, 서브클래스에서는 어떤식으로 커넥션 기능을 제공하는지에 관심을 갖게 된다.

하지만 상속을 사용했을 때의 한계점도 있다.
자바는 다중상속을 허용하지 않기 때문에 이후에 다른 클래스를 상속하기 힘들다.
서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있어서 슈퍼클래스 내부의 변경이 있을 때 서브클래스도 함께 수정해야 할 수도 있다.

그리고 특정 DAO의 커넥션을 생성하는 코드를 추상 메소드로 만들었을 때, 이를 다른 DAO에 적용할 수 없다. 예를 들어, UserDao의 구현 클래스에서 작성된 getConnection() 구현 코드는 다른 DAO에 적용할 수 없으므로 매 DAO 구현 클래스마다 코드가 중복되어 나타날 것이다.

## 인터페이스의 도입
커넥션을 만드는 부분에 추상화를 적용해서 다음과 같이 인터페이스로 만들어볼 수 있다. 커넥션 방식을 변경하려면 ConnectionMaker를 구현한 클래스를 만들어서 메소드를 작성해주면 된다.
```java
public interface ConnectionMaker {
	public Connection makeConnection() throws ClassNotFoundException, SQLException;
}
```

그리고 DAO에서는 특정 구현 클래스롤 사용해 커넥션을 가져오게 하면 된다. 하지만 구현 클래스를 지정하는 코드가 Dao안에 있게 된다. 구현 클래스를 변경하려면 UserDao를 수정해야 한다.
```java
public class UserDao() {
	private ConnectionMaker connectionMaker;

	public UserDao() {
		ConnectionMaker = new DConnectionMaker();
	}
}
```

## 관계설정 책임의 분리
UserDao에는 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 관심사가 존재하고 있다.
이 관심사를 UserDao에서 분리하지 않으면 UserDao는 독립적으로 확장 가능한 클래스가 될 수 없다. UserDao가 특정 구현 클래스에 의존하고 있어서 확장을 하려면 그 코드를 변경해야 하기 때문이다.

ConnectionMaker 구현 클래스를 선택하는 관심을 클라이언트에게 떠넘기면 된다. UserDao를 사용하는 클라이언트에서 ConnectionMaker 구현 클래스를 만들어서 UserDao의 생성자로 전달하게 하는 것이다.
그러면 UserDao에서는 특정 구현 클래스를 결정하는 코드가 사라진다.
```java
// UserDao의 생성자
public UserDao(ConnectionMaker connectionMaker) {
	this.connectionMaker = connectionMaker;
}

```
```java
// UserDaoTest에서 구현 클래스를 만들고 전달
ConnectionMaker connectionMaker = new DConnectionMaker();
UserDao dao = new UserDao(connectionMaker);
```

## 원칙과 패턴
### 개방 폐쇄 원칙
개방 폐쇄 원칙(OCP, Open-Closed Principle)은 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙이다.
예를 들어 UserDao의 DB 연결 방식은 인터페이스를 사용해 기능을 확장하는 데는 열려있고, UserDao 자신의 구현 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀 있다고 할 수 있다.

### 높은 응집도와 낮은 결합도
응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.
응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다. 즉 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 할 수 있다.

낮은 결합도는 책임과 관심사가 다른 오브젝트 또는 모듈이 느슨하게 연결되는 것이다. 느슨한 연결은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 알 필요도 없게 만들어 주는 것이다.
결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다.
결합도란 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에 변화를 요구하는 정도라고 설명할 수 있다.
낮은 결합도란 결국, 하나의 변경이 발생할 때 다른 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다.

### 전략 패턴
전략 패턴은 자신의 기능 맥락(context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

UserDao는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가며 사용할 수 있게 분리했다.

전략 패턴에서는 컨텍스트를 사용하는 클라이언트가 컨텍스트가 사용할 전략을 컨텍스트의 생성자 등을 통해 제공해 주는게 일반적이다.

## 제어의 역전(IoC)
관심사를 분리하면서 UserDaoTest가 ConnectionMaker 구현 클래스를 결정하는 기능을 담당하게 되었다. 
테스트가 목적인 클래스에서 다른 책임을 떠맡게 되는 것은 문제가 있기 때문에 이를 분리해야 한다.

### 팩토리
팩토리 클래스를 만들어서 이를 해결할 수 있다. 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 일을 하는 오브젝트를 팩토리라고 부른다.
다음과 같이 UserDao 오브젝트를 어떻게 만들고 준비시킬지 결정하는 팩토리 클래스를 작성할 수 있다.
```java
public class DaoFactory {
	public UserDao userDao() {
		return new UserDao(connectionMaker());
	}

	public ConnectionMaker connectionMaker() {
		return new DConnectionMaker();
	}
}
```

### 제어관계 역전
제어의 역전이라는 것은 간단하게 말하면 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다.
일반적으로는 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 모든 작업을 사용하는 쪽에서 제어하는 구조다.

제어의 역전에서는 이런 제어 흐름의 개념을 뒤집어 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하거나 생성하지 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다. 모든 제어 권한을 다른 대상에게 위임하기 때문이다.

대표적인 제어의 역전 개념이 적용된 기술로 프레임워크가 있다. 라이브러리는 애플리케이션 코드가 흐름을 제어하고 필요한 때에 능동적으로 라이브러리를 사용한다. 반면 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다.
프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.

UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다.
원래 UserDao에서 ConnectionMaker 구현 클래스를 결정하고 만드는 제어권이 있었는데, 이제는 DaoFactory에게 제어권이 있다. UserDao는 DaoFactory가 공급해주는 것을 수동적으로 사용해야 하는 입장이 되었다.

## 스프링의 IoC

### 애플리케이션 컨텍스트와 설정정보
스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(Bean)이라고 한다.
빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부른다. 보통 빈 팩토리보다는 이를 확장한 애플리케이션 컨텍스트를 주로 사용한다.
애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈 생성, 관계설정 등의 제어 작업을 총괄한다.

스프링의 빈 팩토리가 DaoFactory를 설정정보로 사용할 수 있도록 다음과 같이 작성할 수 있다.
@Configuration을 추가해 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있게 한다.
그리고 오브젝트를 만들어주는 메소드에는 @Bean을 붙여준다.

```java
@Configuration
public class DaoFactory {
	@Bean
	public UserDao userDao() {
		return new UserDao(connectionMaker());
	}

	@Bean
	public ConnectionMaker connectionMaker(). {
		return new DConnectionMaker();
	}
}
```

DaoFactory를 설정정보로 사용하려면 애플리케이션 컨텍스트를 사용하면 된다. 애플리케이션 컨텍스트는 ApplicationContext 타입의 오브젝트로 여러 구현 클래스가 있다.

@Configuration이 붙은 자바 코드를 설정 정보로 사용하려면 AnnotationConfigApplicationContext를 사용하면 된다. 
애플리케이션 컨텍스트를 만들 때 생성자 파라미터로 DaoFactory 클래스를 넣어준다.

그리고 애플리케이션 컨텍스트의 getBean() 메소드를 통해 애플리케이션 컨텍스트가 관리하는 UserDao 오브젝트를 가져올 수 있다.
getBean()에서 파라미터인 "userDao"는 ApplicationContext에 등록된 빈의 이름으로, @Bean이 붙은 메소드의 이름이 빈의 이름이 된다.

```java
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
UserDao dao = context.getBean("userDao", UserDao.class);
```

### 애플리케이션 컨텍스트의 동작방식
애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 그런 생성정보와 연관관계 정보는 별도의 설정정보를 통해 얻는다. 때로는 외부의 오브젝트 팩토리에 그 작업을 위임하고 그 결과를 가져다 사용하기도 한다.

애플리케이션 동작 방식은 다음과 같다.
1. DaoFactory 클래스를 설정 정보로 등록해두고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다.
2. 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출한다.
3. 애플리케이션 컨텍스트는 자신의 빈 목록에서 요청한 이름이 있는지 찾는다.
4. 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 돌려준다.

DaoFactory를 오브젝트 팩토리로 직접 사용하는 대신 어플리케이션 컨텍스트를 사용했을 때의 장점은 다음과 같다.
- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
  - 팩토리 클래스가 많아지면 클라이언트가 어떤 팩토리 클래스를 사용해야 할지를 알아햐 하고, 필요할 때마다 팩토리 클래스를 생성해야 하는 번거로움이 있다.
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
  - 애플리케이션 컨텍스트의 역할은 오브젝트 생성과 관계설정이 전부가 아니다. 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 사용할 수 있는 다양한 기능을 제공한다. 또 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도 한다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
  - 빈의 이름, 빈의 타입, 특별한 애노테이션 설정이 되어있는 빈 등을 찾을 수 있다.

## 싱글톤 레지스트리와 오브젝트 스코프
DaoFactory를 직접 사용하는 것과 스프링 애플리케이션 컨텍스트를 사용하는 것은 중요한 차이점이 있다.
스프링 애플리케이션 컨텍스트는 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.

애플리케이션 컨텍스트는 IoC 컨테이너이면서 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다
스프링은 별다른 설정을 하지 않으면 빈 오브젝트를 모두 싱글톤으로 만든다. 왜 싱글톤으로 빈을 만드는 것일까?

스프링은 엔터프라이즈 시스템을 위해 만들어졌는데, 대규모 엔터프라이즈 서버환경에서는 높은 성능이 요구된다.
그런데 매번 클라이언트 요청이 올 때마다 오브젝트를 새로 만든다고 하면 서버에 부하가 걸리게 되므로 이렇게 싱글톤으로 빈을 만드는 것이다.

#### 싱글톤 패턴의 한계
- private 생성자를 갖고 있기 때문에 상속할 수 없다. 애플리케이션 로직이 담긴 일반 오브젝트의 경우 싱글톤으로 만들었을 때 객체지향적인 설계의 장점을 적용하기가 어렵다.
- 싱글톤은 테스트하기가 힘들다. 싱글톤은 만들어지는 방식이 제한적이어서 테스트에서 목 오브젝트 등으로 대체하기가 힘들다. 생성자를 통해 오브젝트를 다이내믹하게 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 만들어서 사용할 수밖에 없다.
- 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. 서버에서 클래스 로더를 어떻게 구성하고 있는지에 따라 하나 이상의 오브젝트가 만들어질 수 있다. 여러 JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생기게 된다.
- 싱글톤의 사용은 전역 상태를 만들 수 있다. 싱글톤의 스태틱 메소드를 사용해 언제든지 싱글톤에 접근할 수 있기 때문에 어디서든 사용될 수 있고 아무 객체나 자유롭게 접근, 수정, 공유할 수 있는 전역 상태로 사용되기 쉽다.

#### 싱글톤 레지스트리
스프링은 싱글톤 레지스트리 방식을 사용해 평범한 자바 클래스를 싱글톤으로 활용하게 해준다. 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는데 아무 제약이 없다.

### 스프링 빈의 스코프
스프링이 관리하는 오브젝트, 즉 빈이 생성되고 존재하고 적용되는 범위를 빈의 스코프라고 한다.
- 싱글톤 스코프 : 스프링 빈의 기본 스코프는 싱글톤이다. 컨테이너 내에 한 개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
- 프로토타입 스코프 : 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.
- 요청 스코프 : 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성된다.
- 세션 스코프 : 웹의 세션과 스코프가 유사하다.

## 의존관계 주입(DI)
스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확히 설명하지 못한다.
그래서 스프링이 제공하는 IoC 방식의 핵심을 짚어주는 의존관계 주입이라는 좀 더 의도가 명확한 이름을 사용하게 되었다.

### 의존관계 주입의 응용

#### 기능 구현의 교환
예를 들어 운영에서는 운영용 DB를 사용하고 개발 중에는 개발용 DB를 사용하는 것을 DI 방식을 적용해서 다음과 같이 만들 수 있다.
```java
@Bean
public ConnectionMaker connectionMaker() {
	// 개발용 DB
	return new LocalDbConnectionMaker();
}
```
```java
@Bean
public ConnectionMaker connectionMaker() {
	// 운영용 DB
	return new ProductionDbConnectionMaker();
}
```

개발환경과 운영환경에서 DI 설정정보인 DaoFactory만 수정하면 나머지 코드는 전혀 손대지 않고 각각 런타임 오브젝트에 의존관계를 갖게 해줄 수 있다.

#### 부가기능 추가
DAO가 DB를 얼마나 많이 연결해서 사용하는지 파악하고 싶다고 해보자. DI를 사용하면 기존 DB 커넥션을 만드는 코드를 수정하지 않고 기능을 추가할 수 있다.

연결횟수를 카운팅하는 클래스를 ConnectionMaker 인터페이스를 사용해서 구현하면 된다. 커넥션 요청이 있을 때마다 카운트를 한 후 실제 DB 커넥션 생성은 기존 ConnectionMaker 구현 클래스를 호출해서 리턴하게 한다.
실제 커넥션을 생성하는 ConnectionMaker 구현 클래스는 DI 받도록 하면 된다.
